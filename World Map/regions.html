<!DOCTYPE html>
<html>
<meta charset="utf-8">
<style>
path.country {
    fill: none;
    stroke: #777;
    stroke-width: .1;
    /*pointer-events: none;   */
}

path.region {
    fill: none;
    stroke: #777;
    stroke-width: .5;
    opacity: .6;
    pointer-events: none;
}

region:hover {
    fill: red;
    stroke: #d9edf7;
    stroke-width: 1px;
}

.background {
    fill: none;
    pointer-events: all;
}

.region.active {
    fill: orange;
}

.mesh {
    fill: none;
    stroke: #fff;
    stroke-linecap: round;
    stroke-linejoin: round;
}
</style>

<body>
    <div class="legend"></div>
    <div class="view" id="map"></div>
    <script src="http://d3js.org/d3.v4.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>
    <script>
    const width = document.querySelector('#map').offsetWidth;
    const mapRatio = 0.7;
    const height = width * mapRatio;
    const colour_scale = d3.scaleOrdinal(["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#ffff33","#a65628","#f781bf","#999999"]);
    let centered;
    let active = d3.select(null);

    const projection = d3.geoMercator().scale(width / 2 / Math.PI)
        .rotate([-11, 0])
        .translate([(width) / 2, height * 1.35 / 2])

    const path = d3.geoPath().projection(projection);

    const zoom = d3.zoom()
        .scaleExtent([1, 20])
        .on("zoom", zoomed);

    const svg = d3.select("#map")
        .append("svg")
        .attr("preserveAspectRatio", "xMinYMin")
        .attr("width", width)
        .attr("height", height)
        .on("click", stopped, true);

    const background = svg.append("rect")
        .attr("class", "background")
        .attr("width", width)
        .attr("height", height)
        .on("click", reset);

    const g = svg.append("g");

    svg.call(zoom);

    d3.queue()
        .defer(d3.json, 'QGIS no french guinea Topo.json')
        .defer(d3.json, 'regions.json')
        .await(ready);

    function ready(error, countries_topo, regions_geo) {
        if (error) throw error;
                console.log('countries_topo = ', countries_topo)

        console.log('regions_geo = ', regions_geo)

        const countries_geo = topojson.feature(countries_topo, countries_topo.objects['QGIS no french guinea']).features;

        console.log('countries_geo = ', countries_geo)

        // const countries = g.selectAll('.country')
        //     .data(countries_geo)
        //     .enter()
        //     .append("path")
        //     .attr("d", path)
        //     .attr("class", "country")
        //     .on("mouseover", d => console.log(d));

        regions = g.selectAll('.region')
            .data(regions_geo)
            .enter()
            .append("path")
            .attr("d", d => path(d.geo))
            .attr("class", "region")
            .style("fill", (d, i) => colour_scale(i))
            .style("stroke", (d, i) => shade_colour(colour_scale(i), -40))
            .on("mouseover", d => console.log(d))
            .on("click", clicked);
    };

    function clicked(d) {
        var d = d.geo;
        if (active.node() === this) return reset();
        active.classed("active", false);
        active = d3.select(this).classed("active", true);

        let bounds = path.bounds(d),
            dx = bounds[1][0] - bounds[0][0],
            dy = bounds[1][1] - bounds[0][1],
            x = (bounds[0][0] + bounds[1][0]) / 2,
            y = (bounds[0][1] + bounds[1][1]) / 2,
            scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height))),
            translate = [width / 2 - scale * x, height / 2 - scale * y];

        svg.transition()
            .duration(750)
            .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
    }

    function reset() {
        active.classed("active", false);
        active = d3.select(null);

        svg.transition()
            .duration(750)
            .call(zoom.transform, d3.zoomIdentity);
    }

    function zoomed() {
        g.style("stroke-width", 1.5 / d3.event.transform.k + "px");
        g.attr("transform", d3.event.transform);
    }

    function stopped() {
        if (d3.event.defaultPrevented) d3.event.stopPropagation();
    }

    function resize() {
        width = document.querySelector('#map').offsetWidth;
        height = width * mapRatio;

        projection.scale(width / 2 / Math.PI)
            .translate([(width) / 2, height * 1.35 / 2])
            .precision(.1);

        document.querySelector('svg').setAttribute('width', width);
        document.querySelector('svg').setAttribute('height', height);
        svg.selectAll('.regions, .border').attr('d', path);
    }

    function shade_colour(colour, percent) {

    var R = parseInt(colour.substring(1,3), 16);
    var G = parseInt(colour.substring(3,5), 16);
    var B = parseInt(colour.substring(5,7), 16);

    R = parseInt(R * (100 + percent) / 100);
    G = parseInt(G * (100 + percent) / 100);
    B = parseInt(B * (100 + percent) / 100);

    R = (R<255)? R:255;  
    G = (G<255)? G:255;  
    B = (B<255)? B:255;  

    var RR = ((R.toString(16).length==1) ? "0" + R.toString(16): R.toString(16));
    var GG = ((G.toString(16).length==1) ? "0" + G.toString(16): G.toString(16));
    var BB = ((B.toString(16).length==1) ? "0" + B.toString(16): B.toString(16));

    return "#" + RR + GG + BB;
}


    </script>
</body>

</html>